{"version":3,"sources":["components/AddCategory.js","components/GifGridItem.js","helpers/getGifs.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setinputValue","onSubmit","e","preventDefault","console","log","trim","length","cats","type","value","onChange","target","GifGridItem","title","url","className","src","alt","getGifs","category","a","encodeURI","fetch","res","json","data","gifs","map","img","id","images","downsized_medium","GifGrid","loading","state","setState","useEffect","then","imgs","useFetchGifs","GifExpertApp","defaultCategories","categories","ReactDOM","render","document","getElementById"],"mappings":"yMA0CeA,EAtCK,SAAC,GAAuB,IAArBC,EAAoB,EAApBA,cAAoB,EAEHC,mBAAS,IAFN,mBAEhCC,EAFgC,KAEpBC,EAFoB,KAqBvC,OAEI,cADA,CACA,QAAMC,SAfW,SAACC,GAElBA,EAAEC,iBACFC,QAAQC,IAAI,wBAERN,EAAWO,OAAOC,OAAS,IAE3BV,GAAc,SAACW,GAAD,OAAWT,GAAX,mBAA0BS,OACxCR,EAAc,MAOlB,UACI,4BAAID,IACJ,uBACIU,KAAK,OACLC,MAAOX,EACPY,SAxBc,SAACT,GACvBF,EAAcE,EAAEU,OAAOF,c,QCShBG,EAfK,SAAC,GAAoB,IAAlBC,EAAiB,EAAjBA,MAAOC,EAAU,EAAVA,IAC1B,OAEI,cADA,CACA,OAAKC,UAAU,yCAAf,UACI,qBAAKC,IAAKF,EAAKG,IAAKJ,IACpB,4BAAIA,GAAgB,e,uBCNnBK,EAAO,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DAEbN,EAFa,iDAEmCO,UAClDF,GAHe,+DAMDG,MAAMR,GANL,cAMbS,EANa,gBAOIA,EAAIC,OAPR,uBAOXC,EAPW,EAOXA,KAEFC,EAAOD,EAAKE,KAAI,SAACC,GAAD,YAAU,CAC5BC,GAAID,EAAIC,GACRhB,MAAOe,EAAIf,MAEXC,IAAG,UAAEc,EAAIE,cAAN,aAAE,EAAYC,iBAAiBjB,QAbnB,kBAgBZY,GAhBY,4CAAH,sDCsCLM,EAnCC,SAAC,GAAkB,IAAhBb,EAAe,EAAfA,SAAe,ECDN,SAACA,GAAc,IAAD,EACZtB,mBAAS,CAC/B4B,KAAM,GACNQ,SAAS,IAHyB,mBAC/BC,EAD+B,KACxBC,EADwB,KAiBtC,OAVAC,qBAAU,WAENlB,EAAQC,GAAUkB,MAAK,SAACC,GACpBH,EAAS,CACLV,KAAMa,EACNL,SAAS,SAGlB,CAACd,IAEGe,EDf2BK,CAAapB,GAAjCW,EADgB,EACtBL,KAAcQ,EADQ,EACRA,QAOtB,OACI,qCACI,oBAAIlB,UAAU,wCAAd,SACKI,IAEJc,GACG,mBAAGlB,UAAU,mCAAb,sBAEJ,qBAAKA,UAAU,YAAf,SACKe,EAAOH,KAAI,SAACC,GAAD,OAER,aADA,CACC,EAAD,eAA8BA,GAAZA,EAAIC,aEH3BW,EAjBM,SAAC,GAAgC,IAAD,IAA7BC,yBAA6B,MAAT,GAAS,IACb5C,mBAAS4C,GADI,mBAC1CC,EAD0C,KAC9B9C,EAD8B,KAGjD,OACI,qCACI,gDACA,cAAC,EAAD,CAAaA,cAAeA,IAC5B,uBACA,6BACK8C,EAAWf,KAAI,SAACR,GAAD,OACZ,cAAC,EAAD,CAAwBA,SAAUA,GAApBA,YCTlCwB,IAASC,OAAO,cAAC,EAAD,IAAkBC,SAASC,eAAe,W","file":"static/js/main.ce72d6c5.chunk.js","sourcesContent":["\nimport React, { useState } from 'react';\nimport PropTypes from 'prop-types';\n\nconst AddCategory = ({ setCategories }) => {\n    // Si se deja el useState vacío este sería undefined, por ello, se deja un string vacío\n    const [inputValue, setinputValue] = useState(''); //useState('') es lo que va en el buscador\n\n    const handleInputChange = (e) => {\n        setinputValue(e.target.value);\n    };\n\n    const handleSubmit = (e) => {\n        // Debido a que ya no es muy usado la parte del refresh completo del navegador, que es un comportamiento por default de los formularios se utiliza la siguiente linea de código\n        e.preventDefault();\n        console.log('handleSubmit llamado');\n\n        if (inputValue.trim().length > 1) {\n            // Como no se tiene acceso a las categorias del componente padre hace uso un callback como se muestra, el inputValue seria el nuevo valor.\n            setCategories((cats) => [inputValue, ...cats]);\n            setinputValue('');\n            //esto para que quede vacio el coso\n        }\n    };\n\n    return (\n        // Cuando se retorna na unica etiqueta agrupadora como es en este caso el form no es necesario agruparla dentro de un Fragment\n        <form onSubmit={handleSubmit}>    \n            <p>{inputValue}</p>\n            <input\n                type=\"text\"\n                value={inputValue}\n                onChange={handleInputChange}\n            />\n        </form>\n    );\n};\n//el onSubmit es para que no haga refresh osea el handlesubmit con preventdefault\nAddCategory.propTypes = {\n    setCategories: PropTypes.func.isRequired,\n};\n\nexport default AddCategory;","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst GifGridItem = ({ title, url }) => {\n    return (\n        // En los componentes las clases de CSS se asignan por medio de la palabra className, debido a que como se están ocupando archivos de JS, si uno escribe solo class=\"\", REact no sabe si es una clase de CSS o de JS\n        <div className=\"card animate__animated animate__fadeIn\">\n            <img src={url} alt={title} />\n            <p>{title ? title : 'imagen'}</p>\n        </div>\n    );\n};\n\nGifGridItem.propTypes = {\n    title: PropTypes.string.isRequired,\n    url: PropTypes.string.isRequired,\n};\n\nexport default GifGridItem;","\n// Los helpers son funciones que no mutan tal cual el estado del componente, como un evento\nexport const getGifs = async (category) => {\n    // El método encodeURI  codifica espacios y caracteres especiales\n    const url = `https://api.giphy.com/v1/gifs/search?q=${encodeURI(\n        category\n    )}&limit=10&api_key=hgDKm28QdpzAtF4zSKPcKDaWwHuB73AU`;\n\n    const res = await fetch(url);\n    const { data } = await res.json();\n\n    const gifs = data.map((img) => ({\n        id: img.id,\n        title: img.title,\n        // El signo de interrogación después de la palabra images es un condicional y significa que en caso de que se encuentre el image regresará todo la propiedad\n        url: img.images?.downsized_medium.url,\n    }));\n\n    return gifs;\n};","import React /* { useState, useEffect } */ from 'react';\nimport GifGridItem from './GifGridItem';\nimport { useFetchGifs } from '../hooks/useFetchGifs';\nimport PropTypes from 'prop-types';\n\nconst GifGrid = ({ category }) => {\n    const { data: images, loading } = useFetchGifs(category);\n\n    /* useEffect(() => {\n        \n        getGifs(category).then(setImages);\n    }, [category]); */\n\n    return (\n        <>\n            <h3 className=\"animate__animated animate__fadeInDown\">\n                {category}\n            </h3>\n            {loading && (\n                <p className=\"animate__animated animate__flash\">Cargando</p>\n            )}\n            <div className=\"card-grid\">\n                {images.map((img) => (\n                    // Cuando se envían objetos con varias propiedades, como atributo en el lado del componente padre se puede destructurar con el operador Spread\n                    <GifGridItem key={img.id} {...img} />\n                    //images.map(img) => (\n                        //<li key={img.id}>{img.title}}</li>\n                        //es lo mismo sacar el img y dejarlo\n                        //images.map({id, title}) => (\n                            //<li key={id}>{title}}</li>\n                ))}\n            </div>\n        </>\n    );\n};\n\nGifGrid.propTypes = {\n    category: PropTypes.string.isRequired,\n};\n\nexport default GifGrid;","import { useState, useEffect } from 'react';\nimport { getGifs } from '../helpers/getGifs';\n\n// Los hooks por estandar inician con la palabra \"use\" y estos son funciones, tampoco pueden ser asincronos\nexport const useFetchGifs = (category) => {\n    const [state, setState] = useState({\n        data: [],\n        loading: true,\n    });\n\n    // El useEffect condiciona la ejecución de un bloque de código al recibir un arreglo de dependencias, cuando el arreglo está vaío solo lo ejecuta una vez\n    useEffect(() => {\n        // Recibe el nombre de una categoría y muestra un arreglo de los gifs que coincidan con la búsqueda\n        getGifs(category).then((imgs) => {\n            setState({\n                data: imgs,\n                loading: false,\n            });\n        });\n    }, [category]);\n\n    return state;\n};","import React, { useState } from 'react';\nimport AddCategory from './components/AddCategory';\nimport GifGrid from './components/GifGrid';\n\nconst GifExpertApp = ({ defaultCategories = [] }) => {\n    const [categories, setCategories] = useState(defaultCategories);\n\n    return (\n        <>\n            <h2>Gif Expert App</h2>\n            <AddCategory setCategories={setCategories} />\n            <hr />\n            <ol>\n                {categories.map((category) => (\n                    <GifGrid key={category} category={category} />\n                ))}\n            </ol>\n        </>\n    );\n};\n\nexport default GifExpertApp;\n\n\n\n// // const [categories, setCategories] = useState(['boca', 'river']);\n// const handleAdd =() => {\n//     setCategories ([...categories, 'san lorenzo']);\n// }\n// //asi agrego un categoria nueva al presionar un click o se puede hacer asi:\n// setCategories(cats => [...cats, 'san lorenzo']);\n// //el primer argumento es el valor del estado anterior, osea cats, y lo que esta entre [] es el nuevo estado","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport GifExpertApp from './GifExpertApp';\n\nReactDOM.render(<GifExpertApp />, document.getElementById('root'));"],"sourceRoot":""}